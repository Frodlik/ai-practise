### Todo List Application

A simple RESTful API for managing a todo list application built using **Spring Boot**, **Hibernate, and** **MySQL**. The
application supports user management and CRUD operations for todo items. It is designed with best practices, including
DTOs, custom exceptions, and validation.

---

### Features

1. **User Management**:
    - Create, read, update, and delete users.
    - Retrieve users by ID, username, or email.
2. **Todo Item Management**:
    - Create, read, update, and delete todo items.
    - Retrieve todo items by ID or associated user.
3. **Technologies Used**:
    - **Spring Boot:** Framework for building Java applications.
    - **Spring Data JPA:** For database interaction using Hibernate.
    - **MySQL:** Database system for storing user and todo information.
    - **Postman:** For testing API endpoints.
    - **Lombok (Optional):** For reducing boilerplate code (e.g., getters and setters).

---

### Requirements

Before running the application, ensure you have the following installed:

- Java Development Kit (JDK) 11 or higher
- Maven
- MySQL Server
- Postman (for testing the API)

### Getting Started

1. **Clone the Repository**:
   ```bash
   git clone https://github.com/Frodlik/ai-practise.git
   cd todo-app
    ```

2. **Configure the Database**:
    1. Create a MySQL database:
   ```sql
   CREATE DATABASE todo_db;
   ```   
    2. Create a .env file in the root of your project to store database credentials:
    ```env
   MYSQL_DB_URL=jdbc:mysql://localhost:3306/todo_db
   MYSQL_DB_USERNAME=your_mysql_username
   MYSQL_DB_PASSWORD=your_mysql_password
    ```
   3. Make sure .env is added to .gitignore to prevent sensitive information from being pushed to version control:
   ```gitignore
   # .env file
   .env
   ```
   
3. **Run the Application**:
   1. Use Maven to build the project:
      ```bash
      mvn clean install
      ```
   2. Start the Spring Boot application:
       ```bash
       mvn spring-boot:run
       ```
   By default, the application will run on http://localhost:8080.


4. **Test API**
   - **User Endpoints:**
      - `POST /api/v1/users` - Create a new user.
      - `GET /api/v1/users/{id}` - Get user by ID.
      - `GET /api/v1/users/username/{username}` - Get user by username
      - `GET /api/v1/users/email/{email}` - Get user by email
   - **Todo Endpoints:**
      - `POST /api/v1/todos/user/{userId}` - Create a new todo for a user.
      - `GET /api/v1/todos/user/{userId}` - Get all todos for a user.
      - `GET /api/v1/todos/{id}` - Get a todo by ID.
      - `PUT /api/v1/todos/{id}` - Update a todo by ID.
      - `DELETE /api/v1/todos/{id}` - Delete a todo by ID.
      - `GET /api/v1/todos/user/{userId}/completed?completed={true|false}` - Get todos by completion status.

---

### Feedback on Completing Tasks Using AI

1. **Was it easy to complete the tasks using AI?**
   Yes, it was relatively easy to complete the tasks with the help of AI. The AI provided a strong starting point for each layer of the application, offering clear instructions, well-structured code, and best practices for building a RESTful API. However, some manual effort was required to refine the generated code and ensure it adhered to production-quality standards, such as handling edge cases, adding custom validation, and aligning with specific project requirements.
2. **How long did the entire process take you to complete?**
   The entire process took approximately 3-4 hours. This includes time spent on setting up the project, configuring the database, generating code with AI assistance, reviewing and refining the generated code, testing the API endpoints using Postman, and documenting the project. The AI significantly reduced the time required for boilerplate code generation and provided useful suggestions, but additional time was needed for customization and ensuring the application met all functional requirements.
3. **Was the code ready to run after generation? What did you have to change to make it usable?**
   The code generated by AI was a solid foundation and was mostly ready to run. However, some changes were necessary to make it fully usable:
   - **Database Configuration:** I had to set up the database connection properties in the application configuration file and create the database schema.
   - **Custom Validation:** While basic validation was included, I added custom validation logic to ensure data integrity and handle specific business rules.
   - **Error Handling:** I implemented custom exception handling to provide meaningful error responses for various failure scenarios.
   - **Testing and Debugging:** Some debugging was required to fix minor issues and ensure all endpoints functioned as expected.

   Overall, while the AI-generated code provided a great starting point, these adjustments were necessary to tailor the application to specific needs and ensure it was production-ready.
4. **Which challenges did you face during completion of the tasks?**
    - **Understanding AI Limitations:** While the AI provided useful code snippets, it sometimes lacked context about the specific requirements of the project. I had to carefully review and adapt the generated code to fit the application's needs.
    - **Integration Issues:** Integrating different layers of the application (controllers, services, repositories) required careful attention to ensure proper communication and data flow.
    - **Validation and Error Handling:** Implementing robust validation and error handling was challenging, as it required a deep understanding of potential failure scenarios and how to handle them gracefully.
    - **Testing:** Ensuring that all API endpoints worked correctly involved thorough testing with Postman, which revealed some edge cases that needed to be addressed.
    - **Learning Curve:** For those unfamiliar with certain technologies (e.g., Spring Boot, Hibernate), there was a learning curve involved in understanding how to effectively use these tools in conjunction with AI-generated code.
5. **Which specific prompts did you learn as a good practice to complete the tasks?**
    - **Layered Architecture Prompts:** Asking the AI to generate code for specific layers (e.g., "Generate a Spring Boot controller for managing todo items") helped in obtaining well-structured code snippets.
    - **Validation Prompts:** Requesting validation logic (e.g., "Add validation for user email format") ensured that the generated code included necessary checks for data integrity.
    - **Error Handling Prompts:** Inquiring about exception handling (e.g., "Create custom exceptions for user not found") led to more robust error management in the application.
    - **Database Interaction Prompts:** Asking for repository interfaces and JPA queries (e.g., "Generate a JPA repository for Todo entity") facilitated seamless database operations.
    - **Testing Prompts:** Requesting sample Postman requests and responses (e.g., "Provide example Postman requests for creating a user") aided in understanding how to test the API effectively.

### Final Thoughts
Overall, using AI to assist in building the todo list application was a positive experience. It significantly accelerated the development process by providing a strong foundation of code and best practices. However, it also highlighted the importance of human oversight in refining and customizing the generated code to meet specific project requirements. The combination of AI assistance and manual effort resulted in a functional and well-structured application that adheres to industry standards.
